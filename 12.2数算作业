12.2数算作业
倪珺清 2400011455
1.	M909.蛇梯棋
2.	class Solution {
3.	public:
4.	    int snakesAndLadders(vector<vector<int>>& board) {
5.	      int n=board.size();
6.	      int t=0;
7.	      int x[500],y[500],b[500];
8.	      for (int i=n-1;i>=0;i--)
9.	        for (int j=0;j<n;j++){
10.	          x[++t]=i;
11.	          if ((n-i)%2==1) y[t]=j;
12.	          else y[t]=n-j-1;
13.	          b[t]=1000;
14.	        }
15.	      b[1]=0;
16.	      queue<int> q;
17.	      q.push(1);
18.	      while (!q.empty()){
19.	        int p=q.front();
20.	        for (int i=1;i<=6;i++){
21.	          int now=p+i;
22.	          if (now>n*n) continue;
23.	          else if (now==n*n) return b[p]+1;
24.	          if (board[x[now]][y[now]]!=-1) now=board[x[now]][y[now]];
25.	          if (now==n*n) return b[p]+1;
26.	          if (b[p]+1<b[now]){
27.	            b[now]=b[p]+1;
28.	            q.push(now);
29.	          }
30.	        }
31.	        q.pop();
32.	      }
33.	      return -1;
34.	    }
35.	};
 
耗时：30min
2. sy382: 有向图判环 中等
#include <bits/stdc++.h>
using namespace std;
int n,m,x,y,t;
bool b[101][101],visited[101],c[101];
void dfs(int k){
  if (t==1) return;
  //c[k]代表k是否在当前连通块中，如果再次被搜索到，则代表成环
  c[k]=true;
  for (int i=0;i<n;i++)
    if (b[k][i] && !visited[i]){
      if (c[i]){
      	t=1;return;
	  }
	  else dfs(i);
	}
  c[k]=false;visited[k]=true;
  return;
}
int main(){
  scanf("%d%d",&n,&m);
  for (int i=1;i<=m;i++){
  	scanf("%d%d",&x,&y);
  	b[x][y]=true;
  }
  //visited[i]表示i是否已经被搜索过，若是则代表无需再次搜索
  for (int i=0;i<n;i++){
    if (!visited[i])
      dfs(i);
    if (t==1) break;
  }
  if (t==1) printf("Yes");
  else printf("No");
  return 0;
}
 
耗时：20min
3.词梯
#include <bits/stdc++.h>
using namespace std;
char s[4001][5],s1[5],s2[5];
bool visited[4001];
int f[4001];
vector<vector<int>> adj;
int main(){
  int start,end,n;
  scanf("%d",&n);
  for (int i=1;i<=n;i++)
    scanf("%s",s[i]);
  scanf("%s%s",s1,s2);
  for (int i=1;i<=n;i++){
    if (strcmp(s[i],s1)==0) start=i;
    if (strcmp(s[i],s2)==0) end=i;
  }
  adj.resize(n+1);
  for (int i=1;i<n;i++)
    for (int j=i+1;j<=n;j++){
      int p=0;	
      for (int k=0;k<4;k++)
        if (s[i][k]==s[j][k]) p++;
      if (p==3){
      	adj[i].push_back(j);
      	adj[j].push_back(i);
	  }
	}
  queue<int> q;
  q.push(end);
  visited[end]=true;
  int t=0;
  while (!q.empty()){
  	int p=q.front();
  	for (int i=0;i<adj[p].size();i++){
  	  if (adj[p][i]==start){
  	  	f[start]=p;
  	  	t=1;
  	  	break;
	  }
  	  if (!visited[adj[p][i]]){
  	  	f[adj[p][i]]=p;
  	  	q.push(adj[p][i]);
  	  	visited[adj[p][i]]=true;
	  }
    }
    if (t==1) break;
  	q.pop();
  }
  if (t==1){
    int p=start;
    while (p!=end){
  	  printf("%s ",s[p]);
  	  p=f[p];
    }
    printf("%s",s[end]);
  }
  else printf("NO");
  return 0;
}
 
耗时：25min
4. M433.最小基因变化
class Solution {
public:
    int minMutation(string startGene, string endGene, vector<string>& bank) {
      bank.push_back(startGene);
      vector<vector<int>> adj;
      int n=bank.size();
      adj.resize(n);
      for (int i=0;i<n;i++)
        for (int j=i+1;j<n;j++){
          int p=0;
          for (int k=0;k<8;k++)
            if (bank[i][k]==bank[j][k]) p++;
          if (p==7){
            adj[i].push_back(j);
            adj[j].push_back(i);
          }
        }
      queue<int> q;
      q.push(n-1);
      int f[100],t=0,ans=-1;
      bool visited[100];
      memset(visited,false,sizeof(visited));
      memset(f,0,sizeof(f));
      visited[n-1]=true;
      while (!q.empty()){
        int p=q.front();
        for (int i=0;i<adj[p].size();i++){
          if (bank[adj[p][i]]==endGene){
            ans=f[p]+1;
            t=1;
            break;
          }
          if (!visited[adj[p][i]]){
            q.push(adj[p][i]);
            visited[adj[p][i]]=true;
            f[adj[p][i]]=f[p]+1;
          }
        }
        if (t==1) break;
        q.pop();
      }
      return ans;
    }
};
 
耗时：15min
5.兔子与樱花
#include <bits/stdc++.h>
using namespace std;
int n,m,f[100],k,adj[100][100],r,d[100];
string s[100],s1,s2;
bool v[100];
int main(){ 
  cin>>n; 
  map<string,int> maps;
  for (int i=1;i<=n;i++){
  	cin>>s[i];
  	maps[s[i]]=i;
  }
  cin>>m;
  memset(adj,0x3f,sizeof(adj));
  for (int i=1;i<=m;i++){
  	cin>>s1>>s2>>k;
  	adj[maps[s1]][maps[s2]]=k;
  	adj[maps[s2]][maps[s1]]=k;
  }
  cin>>r;
  while (r--){
  	cin>>s1>>s2;
  	if (s1==s2){
  	  cout<<s1<<endl;
  	  continue;
	}
	int p1=maps[s1],p2=maps[s2];
	memset(v,false,sizeof(v));
	for (int i=1;i<=n;i++) d[i]=1000000000;
	d[p2]=0;
	for (int i=1;i<=n;i++){
	  int mind=1000000000,p;
	  for (int j=1;j<=n;j++)
	    if (!v[j] && d[j]<mind){
	      mind=d[j];
	      p=j;
		}
	  if (p==p1){
	  	while (p!=p2){
	  	  cout<<s[p]<<"->("<<adj[p][f[p]]<<")->";
	  	  p=f[p];
		}
		cout<<s[p]<<endl;
		break;
	  }
	  v[p]=true;
	  for (int j=1;j<=n;j++)
	    if (!v[j] && adj[p][j]+d[p]<d[j]){
	      d[j]=adj[p][j]+d[p];
	      f[j]=p;
		}
	}
  }
  return 0;
}
 
耗时：40min
6.骑士游历
#include <bits/stdc++.h>
using namespace std;
int t,n,x,y,f[20][20];
int dx[8]={2,2,1,1,-1,-1,-2,-2};
int dy[8]={1,-1,2,-2,2,-2,1,-1};
bool v[20][20];
bool cmp(pair<int,int> a,pair<int,int> b){
  int xa=a.first,xb=b.first;
  int ya=a.second,yb=b.second;
  return f[xa][ya]<f[xb][yb];
}
void dfs(int x,int y,int k){
  if (t==1) return;
  if (k==n*n){
  	t=1;return;
  }
  int nx,ny,tx,ty,mind=10;
  vector<pair<int,int>> p;
  for (int i=0;i<8;i++){
  	nx=x+dx[i];ny=y+dy[i];
  	if (nx<0 || ny<0 || nx>=n || ny>=n) continue;
  	if (v[nx][ny]) continue;
  	p.push_back({nx,ny});
  }
  sort(p.begin(),p.end(),cmp);
  for (int i=0;i<p.size();i++){
  	int xa=p[i].first,ya=p[i].second;
  	for (int j=0;j<8;j++){
  	  if (xa+dx[j]<0 || ya+dy[j]<0 || xa+dx[j]>=n || ya+dy[j]>=n) continue;
  	  f[xa+dx[j]][ya+dy[j]]--;
    }
  	v[xa][ya]=true;
  	dfs(xa,ya,k+1);
  	v[xa][ya]=false;
  	for (int j=0;j<8;j++){
  	  if (xa+dx[j]<0 || ya+dy[j]<0 || xa+dx[j]>=n || ya+dy[j]>=n) continue;
  	  f[xa+dx[j]][ya+dy[j]]--;
    }
  } 
  return;
}
int main(){
  scanf("%d",&n);
  scanf("%d%d",&x,&y);
  for (int i=0;i<n;i++)
    for (int j=0;j<n;j++)
      for (int k=0;k<8;k++)
        if (i+dx[k]>=0 && i+dx[k]<n && j+dy[k]>=0 && j+dy[k]<n)
          f[i][j]++;
  for (int j=0;j<8;j++){
  	  if (x+dx[j]<0 || y+dy[j]<0 || x+dx[j]>=n || y+dy[j]>=n) continue;
  	  f[x+dx[j]][y+dy[j]]--;
    }
  v[x][y]=true;
  dfs(x,y,1);
  if (t==1) printf("success");
  else printf("fail");
  return 0;
}
 
耗时：45min


学习收获：学习了最短路，以及有向图环的判断，巩固了dfs和bfs。骑士游历这个题也是没想到会时间超限，学习了一些优化算法。
